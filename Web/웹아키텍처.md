# 웹 아키텍쳐

## 개요

기존 WPF로 구성된 프로그램을 웹 구조로 변환해야해 저번 포스팅에서는 웹 서버와 WAS에 차이를 알아보았다.

이번 포스팅에서는 웹 아키텍쳐가 무었이고 왜 사용하는지 알아려보려한다.

## 아키텍쳐

아키텍쳐는 SW 시스템이나 APP을 설계하고 구성하는 전체적인 틀이다.

아키텍쳐를 설계하는 이유는 시스템 구조를 명확히 정의해서 유지보수 하기 쉽고 관리하기 쉬운 코드를 작성하기 위해 설계한다.

예를 들어 처음 SW 개발을 시작 할 때 규칙없이 코드를 작성하다 덩치가 커지면 관리하기도 쉽지않고 수정,추가도 쉽지않다.

그래서 특정 한 규칙을 통해 만들다 보면 규칙들이 반복되어서 특정한 패턴이 만들어지고 이런 패턴들이 모여서 전체적인 구조인 아키텍쳐를 형성하게 된다.

좋은 아키텍쳐는 구조들을 잘 분류 하는것 이고, 좋은 분류를 하기위해 나온게 디자인패턴이다.

## MVC (Model - View - Controller)

MVC 개념은 아키텍쳐마다 언어마다 환경마다 다 다르지만 여기서는 Web 기준으로 이해해보자.

초기 개발자들은 UI가 있는 SW를 개발하다보니 MVC를 Model, View, Controller로 나누는게 좋다고 봤다.

초창기 프론트엔드 라는 개념도 없을때 웹서비스 MVC는 아래 처럼 구분했고 서버에서 화면을 직접 생성하는 방식이었다.

- Model : DB
- View : HTML,CSS,JS 클라이언트 영역
- Controller : 라우터(PHP,JSP,루비 온 레일즈)를 통해 데이터를 처리하고 새로운 HTML을 만들어서 보여주는 백엔드 영역

이후 프론트엔드 개발이 진화하면서 클라이언트에서 데이터와 화면을 조작하는 방식이 강조 되면서 MVC 개념이 바뀌게된다.

- Model : ajax를 통해 받는 데이터
- View : html, css로 만들어지는 화면
- Controller : js를 통해 Veiw와 Model의 가운데서 데이터를 받아 화면을 바꾸고, 이벤트를 처리해 데이터를 서버에 전달하는 역할 기존 라우터가 하던 역할들을 클라이언트의 JS가 처리하게 됬음

ajax 기술이 생기고, jQuery를 활용한 Dom조작이 활발하게 이루어지고 RESTFUL API로 받아온 데이터가 Model 되었다.

> ajax는 js를 통해 비동기 방식으로 서버와 브라우저가 데이터를 교환하는 통신 방식이다. 데이터가 변경되더라도 페이지를 새로고침 하지않고 업데이트 할 수 있다.

## MVVM (Model - View - ViewModel)

동적 노드 작업이 증가하면서 DOM 조작 관련 코드가 많아지게 되었고, 백엔드에서는 템플릿을 이용해 선언적으로 작업 할 수있지만 프론트에서는 일일이 수정해야하는 불편함이 있었다.
이렇게 해서 만들어 진게 Model View ViewModel이다.

DOM 조작 등은 프레임워크랑 라이브러리가 처리해주고 View를 그리는 Model만 다루게 됬다.

기존에 class나 id 통해 간접적으로 HTML을 접근 했다면 이제는 직접적으로 HTML에 접근 하는 방식으로 확장되었다. (리액트 JSX문법 생각)

MVVM 프레임워크 종류

- React
- Vue
- Angular
- 기타등등

> 선언적인 처리방식은 사용자가 원하는 결과만 명시하고 DOM에 보여주기 위한 과정은 프레임워크나, 라이브러리가 처리해주는 방식

## Container - Presenter

MVVM을 얻은 웹 프론트엔드 개발은 DOM API를 잘다루지 못해도 비지니스 로직에만 집중한다면 금방서비스를 만들 수 있어 개발 생산성이 엄청 향상하게 된다.

웹 서비스가 발전하면서 하나의 Page단위가 아니라 Page안에 여러가지 모듈이있고 Modal이나 여러 화면들이 하나의 화면에서 구성할 수 있도록 발전 하게된다.

그래서 MVVM은 화면 단위가 아니라 조금 더 작게 재사용 할 수 있는 단위로 만들어서 조립하는 방식으로 발전하게 되고 이 방식이 컴포넌트 패턴이다.

컴포넌트를 설계할 때는 재사용이 가능해야하고, 가급적 비지니스 로직을 포함하지 않는 것이 좋다.

하지만 비지니스 로직을 포함할 컴포넌트도 필요해졌고 비지니스 로직은 포함하고 있는 컴포넌트를 Container 컴포넌트라고 하고, 비지니스 로직을 가지고 있지 않고 데이터만 뿌려주는 형태의 컴포넌트를 Presenter 컴포넌트라고한다.

## FLUX

위의 방식으로 설계하는 방법도 괜찮았지만, 컴포넌트의 깊이가 깊어지면 props drilling이 발생하게 된다.

쉽게 말해 부모의 상태를 자식으로 전달할때 부모의 상태가 필요없는 자식 컴포넌트들도 부모의 상태를 가져야하는 문제가 있다는 뜻이다.

그래서 View와 비지니스 로직을 분리해 단방향 데이터 구조를 가진 FULX패턴이 대두되고, Redux등 을 사용하면서 이런 방식의 형태가 주류가 됬다.

FLUX 패턴은 아키텍쳐만 공개되었고 실체는 없었기에 바로 쓰이지는 않았고 아젠다를 만들어주는 정도에서 그쳤다.

## Redux

이후 FLUX 패턴을 이용한 구현체인 Redux가 탄생하게 되고 Redux는 기존 props drilling 문제를 해결해 주었다.

1. View가 Dispath를 통해 Action 전달
2. Action은 Reducer를 통해 Data를 Store 보관
3. Store에 있는 데이터를 View로 연결

Action -> Dispatch(reducer) -> Store -> View

이떄부터 비지니스 로직을 컴포넌트에서 분리하고, 별도로 관리하는 도구들이 주류가 됬고 이런 개념을 상태관리라고 부르게된다.

대표적인 상태관리 라이브러리는 Redux,Vuex 등이 있다.

하지만 이런 단방향 데이터 흐름을 가진 FLUX 패턴도 한계가 있다.

1. 높은 학습곡선
2. 보일러 플레이트 (반복적으로 비슷한 형태의 코드)

그리고 간단한 구조에서 props drilling 는 치명적인 문제가 되지 않았고, 상태 관리를 위해 Action, Dispatch, Reducer를 만들고 관리하는데 더 많은 리소스가 들어 오히려 더 어려워 진다는 문제가 있엇다.

## Observer Pattern

이후 다른 방법으로 propdrilling 문제를 해결해보자는 의견도 있었다.

복잡한 Dispatch와 Action을 배제하고 값이 바뀔때 바뀐 값을 모두에게 전달 한다는 개념이다.

예를 들어 유튜브를 구독하고 구독한 유튜브의 상태(새로운영상?)가 변하면 알림을 보내주는 형태이다.
